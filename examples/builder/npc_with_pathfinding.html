<!DOCTYPE html>
<html lang=en>

<head>
    <meta charset=utf-8 />
    <meta content="text/html; charset=utf-8" http-equiv=Content-Type />
    <title>Builder with NPC - Example game using GameBlocks.js</title>

    <style type="text/css">
        #container canvas {
            border: 10px solid #6c906c;
        }
        #container {
            padding-bottom: 1em;
        }
    </style>
</head>
<body>

<h1>Builder with NPC</h1>
<p>Use your arrow keys to move around. Press SPACE to build a wall where you are. Hold DELETE or D to destroy a wall in the direction you are going.</p>
<div id="container"></div>

<p>Built using <a href="https://github.com/shazow/gameblocks.js">gameblocks.js</a></p>

<script src="../../externs/Class.js"></script>
<script src="../../externs/unstdlib.js"></script>
<script src="../../externs/Dom.js"></script>

<script src="../../src/Camera.js"></script>
<script src="../../src/Clock.js"></script>
<script src="../../src/Engine.js"></script>
<script src="../../src/Entity.js"></script>
<script src="../../src/Input.js"></script>
<script src="../../src/Renderer.js"></script>
<script src="../../src/State.js"></script>
<script src="../../src/Intelligence.js"></script>

<script type="text/javascript">

    // Constants
    var WIDTH=50, HEIGHT=30, MAGNIFY=10;

    // Define the confines of our world to check for boundary-collision
    var world_box = {x: 0, y: 0, width: WIDTH, height: HEIGHT};

    // Create our game objects
    var container = Dom.select("#container");
    var camera = new Game.Camera(container, {width: WIDTH*MAGNIFY, height: HEIGHT*MAGNIFY});
    var renderer = new Game.Renderer(camera, 1);
    var state_machine = new Game.StateMachine();
    var input = new Game.Input();

    // Make a 2d array grid of 0's
    var world = unstdlib.make_grid_fast(world_box, 0);

    // Store the player position
    var player_pos = {x: 15, y: 15};

    // Waypoints for pathfinding
    var next_waypoint = unstdlib.cycle([{x: 0, y: 0}, {x: WIDTH-1, y: HEIGHT-1}]);

    // NPC
    var npc_queue = [];
    var npc_pos = {x: 0, y: 0};
    var npc_goal = next_waypoint();

    // Define what our tiles will look like based on the value
    // TODO: Use image tiles instead of filled colors
    var tile_styles = {
        0: 'rgb(250,250,250)', // Blank
        1: 'rgb(180,240,180)', // Wall
        2: 'rgb(160,50,200)', // Player
        3: 'rgb(250,120,120)' // NPC
    };

    // Helper code for rendering our world (used in our 'world' State)
    var ctx = renderer.layers[0];
    var render_world = function() {
        var last_val = 0;
        ctx.fillStyle = tile_styles[last_val];

        // Traverse the visible world and re-paint it onto our canvas context.
        unstdlib.iter_box(world_box, function(x, y) {
            var val = world[x][y];

            // Should we paint the player here instead of the world texture? Or the NPC?
            if(player_pos.x == x && player_pos.y == y) {
                val = 2;
            } else if(npc_pos.x == x && npc_pos.y == y) {
                val = 3;
            }

            // Changing fillStyle is slow, do it less often.
            if(val!=last_val) {
                last_val = val;
                ctx.fillStyle = tile_styles[last_val];
            }

            ctx.fillRect(x*MAGNIFY, y*MAGNIFY, MAGNIFY, MAGNIFY);
        });
    }

    // Define player movement delta values for input actions
    var player_motions = {
        'right': {x: 1, y: 0},
        'left': {x: -1, y: 0},
        'down': {x: 0, y: 1}, // Our grid is upside-down for convenience
        'up': {x: 0, y: -1}
    }

    // Bind input keys to actions
    input.bind({
        'RIGHT_ARROW': 'right',
        'LEFT_ARROW': 'left',
        'DOWN_ARROW': 'down',
        'UP_ARROW': 'up',
        'SPACE': 'build',
        'DELETE': 'destroy',
        'D': 'destroy'
    });


    // Helper function to check for collision (used in our 'world' State)
    var is_collision = function(pos) {
        return world[pos.x][pos.y] == 1;
    }

    state_machine.add('world', {
        'run': function() {
            render_world();

            var x = player_pos.x, y = player_pos.y;

            if(input.pressed['build']) {
                world[x][y] = 1; // Set current world position to 'wall'
            }

            // Move the player?
            var has_moved = false;

            // Update position delta based on pressed keys
            for(var action in player_motions) {
                if(!input.pressed[action]) continue;

                var delta = player_motions[action];
                x += delta.x;
                y += delta.y;

                has_moved = true;
            }

            // Move the NPC
            if(npc_queue.length == 0) {
                npc_goal = next_waypoint();
                npc_queue = find_path(npc_pos, npc_goal);
            }

            var new_npc_pos = npc_queue.shift();
            if(!new_npc_pos || is_collision(new_npc_pos)) {
                npc_queue = find_path(npc_pos, npc_goal);
            } else {
                npc_pos = new_npc_pos;
            }

            if(!has_moved) return; // Nothing left to do.

            if(input.pressed['destroy']) {
                world[x][y] = 0; // Destroy the wall!
            }

            var new_pos = {x: x, y: y};

            // Is the player move valid?
            if(unstdlib.in_boundary(new_pos, world_box) && !is_collision(new_pos)) {
                // Update the player's position
                player_pos = new_pos;
            }
        }
    });

    state_machine.enter('world'); // Start the state machine at 'world'

    var engine = new Game.Engine(state_machine);
    engine.start(20); // 20 fps feels better here than the default 30fps due to unrestricted movement speed

    input.keyboard_start();


    /**
     * Example cost estimating heuristic, using Manhattan Distance.
     * More here: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
     */
    function builder_estimate_cost_fn(a, b) {
        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
    }

    var neighbor_directions = [
        {x: 0, y: 1},
        {x: 1, y: 0},
        {x: 0, y: -1},
        {x: -1, y: 0}
    ];
    function builder_neighbors_fn(pos) {
        var r = [];
        for(var i=0; i<4; i++) {
            var d = neighbor_directions[i];
            var p = {x: pos.x + d.x, y: pos.y + d.y};

            if(!unstdlib.in_boundary(p, world_box)) continue; // Must be in our boundary
            if(world[p.x][p.y]==1) continue;

            r.push(p);
        }

        return r;
    }

    function builder_distance_fn(a, b) {
        return 1; // Hack: We know all compared distances will be equally-spaced neighbors in this case.
    }

    function builder_compare_fn(a, b) {
        // Sort by (y, x)
        var col = a.y - b.y;
        if(col!=0) return col;
        return a.x - b.x;
    }

    function builder_serialize_fn(pos) {
        return pos.x + ',' + pos.y;
    }

    function find_path(start, goal) {
        var r = Game.pathfind_astar(start, goal, builder_estimate_cost_fn, builder_neighbors_fn, builder_distance_fn, builder_compare_fn, builder_serialize_fn);

        if(r===false) return [];
        r.push(goal);
        return r;
    }

</script>

</body>

</html>
